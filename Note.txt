QA
1.建造者模式是什么？


一.术语
面向对象思想进行抽象化的目的：
可维护、可扩展、可复用、灵活性好

聚合：
雁群--聚合-->大雁，聚合是一个弱拥有关系。A对象可以包含B对象，但是B对象不是A对象的一部分。

组合or合成：
大鸟--组合-->翅膀，是一个强拥有关系。严格要求两者生命周期相同，并且大鸟由翅膀组成（也叫合成）。

单一职责原则（SRP）：
就一个类而言，应该仅有一个引起它变化的原因（ASD）。如果有多余一个的动机去改变一个类，那就要考虑分离。
比如游戏的玩法和界面显示，不能耦合在一起，要进行分离。

开放-封闭原则：
对扩展开放，对更改封闭。	Open for extension，Closed for modification.
理念是，面对一个新需求，对程序的改动是通过增加新代码（新类），而不是现有代码（现有类）。不希望多次去修改过去的代码。
比如弹性工作制，抓住8小时工作制的核心：对工作时间的8小时进行封闭，不可修改；对于时间制度的扩展进行开放，不限死上下班时间。

依赖倒置原则：
A.高层不应该依赖低层模块，两个都应该依赖于抽象。
B.抽象不应该依赖细节，细节应该依赖抽象。
上述两句简单来说就是要面向接口编程，而不是面向一个具体的实现。
比如电脑CPU给出固定针脚，只在乎你的针脚是否能匹配，而不去在乎具体是怎样的技术实现的它或者是谁生产的它。不同层级的组件（类）之间只在乎接口对不对的上。

里氏替换原则（LSP）：
子类型必须能够替换掉它们的父类型。这是一个要遵守的规则，从而实现开放-封闭。
比如子类型不能在继承父类型之后，重新创造某个同名方法并改写逻辑。

迪米特法则：
一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话。

依赖注入（Dependency Injection）：
通过注入的方式，反射查找到文件名来进行函数的加载。常用于配置文件，和控制反转一起出现的概念。

合成/聚合复用原则：
尽量使用合成/聚合，尽量不要使用类继承。

二.设计模式
1.简单工厂模式 Factory
・将类进行区分，子类分别实现父类的一个虚方法。
・将生成实例进行区分，生成的具体实例，通过一个Factory来返回。

2.策略模式 Strategy
・基于简单工厂。
・对于算法多变的情况，每次添加一个新的算法类，就需要给Factory添加一个新的case以便返回新的实例。
如果不希望经常改动Factory，那我们就在初始化的时候直接把算法类传进去，用父类接住。并且给这个Factory里增加一个方法，来调用父类的虚方法。
这就是策略模式。

3.装饰模式 Decorator
・动态地给一个对象添加一些额外的职责，就添加功能来说，装饰模式比生成子类更为灵活。
・把所需要的功能按正确的顺序串联起来进行控制，代码实现的结果是有顺序的。
・让他们直接使用base.Method()，从而实现只需要关心自己的功能与职责，而不用关心怎么去加入总职责的顺序链(点2)。
・装饰模式的存在意义是为了使父类不那么臃肿，只带有自己的核心机能，特殊的情况留给子类自己去做。
比如我们的base，就可以一层一层，先继承，把base.Method()调用上，然后写自己的功能即可。

4.代理模式 Proxy
・为其他对象提供一种代理以控制对这个对象的访问。使得在访问原对象时前、后拥有一些间歇，在这个间歇做一些类似于检查等等的业务处理。
・远程代理。为一个对象在不同的地址空间提供局部代表，从而隐藏一个对象存在于不同地址空间的事实。
・虚拟代理。打开网页，虚拟图片大小框体（代理类里存着这些），再慢慢加载图片。
・安全代理。控制真实访问对象时的权限。
・智能指引。对真实对象的调用时，按需求多加入一些逻辑处理。

5.工厂方法模式 Factory Method
・定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
・实现了在简单工厂模式中的，工厂与其分支的解耦（即消去了switch-case新增case操作）。

6.原型模式 Prototype
・用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
・需要实现Clone()，在.Net中封装为了一个接口ICloneable，实现即可。
・动态地获得对象运行时的状态。
MemberwiseClone是浅表复制，对于值类型是直接复制数值，对于引用类型是复制引用

7.模板方法模式 Template
・定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法某些特定步骤。
用来提取公共行为。是非常常用的设计模式。

8.外观模式 Facade
・为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
老系统可以包装起来做一个外观模式Facade类，负责给新系统提供功能接口，调用即可，而具体实现由自己承担。

9.建造者模式 Builder
・将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
主要用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。

10.观察者模式 Observer Publish/Subscribe
・一对多的关系，让多个观察者对象监听一个主题对象。主题对象状态发生变化时，会通知所有观察者，让他们自动更新自己。

11.抽象工厂模式 Abstract Factory
・提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。
结合反射Assembly.Load(AssemblyName).CreateInstance(className)来实现，可以解决指定具体工厂的繁杂问题。
结合反射的读取配置文件ConfigurationManager.AppSettings["KEY"]。

12.状态模式 State
・当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
面对if-else if很多的情况下，可以考虑用。

13.适配器模式 Adapter
・将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
对于接口不适配，能重构，优先重构。重构太过复杂，再考虑适配器。

14.备忘录模式 Memento
・在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先的状态。
拥有
Memento(备忘录类),拥有发起人的一些状态
Originator(发起人),拥有创建和读取备忘录的方法
Caretaker(管理者),拥有一个备忘录类

15.组合模式 Composite
・将对象组合成树状结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
采用透明方式，客户代码无需区分是组合（枝）还是叶，调用方法完全一样。
透明方式，叶和枝继承一个父类，叶自己没法实现的方法，方法体就用空的。

16.迭代器模式 Iterator
・提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
foreach本质就是对迭代器进行IEnumerator<T>.Next()遍历，所以能不需要提前告知类的type。

17.单例模式 Singleton
・保证一个类仅有一个实例，并提供一个访问它的全局访问点。
让一个全局变量自身去保存一个自己的实例，这个实例禁止其他人创建，但提供接口以供访问。

18.桥接模式 Bridge
・将抽象部分与它的实现部分分离，是他们都可以独立地变化。
实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让他们独立变化，减少它们之间的耦合。
比如手机软件（软件可变）和手机（品牌可变）。

19.命令模式 Command
・将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化：对请求排队或记录请求日志，以及支持可撤销的操作。
比如食客对服务员点菜，服务员记录，并向后厨发送记录的指令，后厨只管执行。

20.职责链模式 Chian of Responsibility
・使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
当客户提交一个请求时，请求沿着一个链不停向下一位负责人传递，直到传递到可以处理该请求的负责人手里，再执行。

21.中介者模式（调停者）Mediator
・用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地互相引用，从而使其耦合松散，并且可以独立地改变他们之间的交互。
比如国家之间的联合国。有些类似于发布者-订阅者模式中的中介。

22.享元模式 Flyweight
・运用共享技术有效地支持大量细粒度的对象。
比如Object.ReferenceEquals(obj a,obj b)就是去判断2个是不是指向同一个实例（资源复用）。

23.解释器模式 Interpreter
・给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释其使用该表示来解释语言中的句子。
比如正则。

24.访问者模式 Visitor
・表示一个作用于某对象结构中的个元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
双分派。用一个状态（成功、失败、恋爱、结婚）visitor去访问不同的元素对象elements（“男性”还是“女性”）。得到的结果与两者都有关。
这种模式要求元素对象elements（男性、女性）是确定的。